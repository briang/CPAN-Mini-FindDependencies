#!/usr/local/bin/perl

use 5.010;

use strict;
use warnings FATAL => 'all';
#use diagnostics;

use Data::Dump;
#use Carp qw();

$|=1;
################################################################################
use MooseX::Declare;

class CPAN::Mini::FindDependencies {
    use autodie;
    use Archive::Peek;
    use CPAN::Meta;
    use Parse::CPAN::Packages::Fast;

    has qw(cpan_mini           is ro isa Str required 1);
    has qw(authors_path_prefix is ro isa Str);
    has qw(packages_details    is ro isa Str);
    has qw(include_suggests    is ro isa Bool default 0);
    has qw(include_recommends  is ro isa Bool default 1);
    has qw(prefer_yaml         is ro isa Bool default 0);
    has qw(dependencies        is ro isa HashRef),
      default => sub { {} },
      traits  => ['Hash'],
      handles => {
          add_dependency => 'set',
          get_children   => 'get',
          get_parents    => 'keys',
          seen_parent    => 'exists',
      };

    sub BUILDARGS {
        my ($class, %args) = @_;

        my $cpan = $args{cpan_mini} || '';

        $args{authors_path_prefix} ||=
          join "/", $cpan, qw(authors id); # XXX
        $args{packages_details} ||=
          join "/", $cpan, qw(modules 02packages.details.txt.gz); # XXX

        return \%args;
    }

    method add_dependants(Str @deps) {
        while (@deps) {
            my $parent = pop @deps;
            next if $parent =~ /^(?:Config|DynaLoader)$/; # XXX Exists, but aren't indexed
            next if $self->seen_parent($parent);
            my $path_suffix = $self->get_distpath_containing($parent);
            my $prereqs     = $self->get_prereqs($path_suffix);
            my $children    = $self->flatten_prereqs($prereqs);

            $self->add_dependency($parent, $children);
            $self->add_dependants(@$children);
        }
    }

    method convert_meta(Str $filename, Str $contents) {
        my $is_json = $filename =~ /\.json/i;
        my $method  = join '_', 'load', ($is_json ? 'json' : 'yaml'), 'string';

        return eval { CPAN::Meta->$method($contents) };
    }

    method flatten_prereqs(HashRef $prereqs) {
        my %uniq_prereqs;
        for my $phase (keys %$prereqs) {
            next if $phase eq 'conflicts'
                 || $phase eq 'recommends' && ! $self->include_recommends
                 || $phase eq 'suggests'   && ! $self->include_suggests;
            for my $rel (keys %{$prereqs->{$phase}}) {
                $uniq_prereqs{$_} = 1
                  for keys %{$prereqs->{$phase}{$rel}};
            }
        }

        delete $uniq_prereqs{perl};
        return [ sort { lc $a cmp lc $b } keys %uniq_prereqs ];
    }

    method get_meta_name(ArrayRef[Str] $files) {
        my ($json, $yaml);
        for (@$files) {
            $json = $_ if m{^[^/]*/META\.json$};
            $yaml = $_ if m{^[^/]*/META\.yml$};
            return $yaml if $yaml && $self->prefer_yaml;
            return $json if $json && $self->prefer_json;
        }

        return $json || $yaml;
    }

    method get_prereqs(Str $path_suffix) {
        my $archive = join "/", $self->authors_path_prefix, $path_suffix; # XXX
        return {} unless -e $archive;

        my $peek  = Archive::Peek->new(filename => $archive);
        my @files = $peek->files;

        my $meta_file     = $self->get_meta_name(\@files);
        return {} unless $meta_file;
        my $meta_contents = $peek->file($meta_file);
        my $meta          = $self->convert_meta($meta_file, $meta_contents);

        return $meta->effective_prereqs->as_string_hash;
    }

    method get_distpath_containing(Str $package_name) {
        state $parser = Parse::CPAN::Packages::Fast->new($self->packages_details); # XXX make attribute

        my $mod  = $parser->package($package_name);
        my $dist = $mod->distribution;
        my $path = $dist->pathname;

        return $path;
    }

    method prefer_json() { ! $self->prefer_yaml }
};
################################################################################
my $dep_finder = CPAN::Mini::FindDependencies->new(
    cpan_mini => "/mirrors/cpan",
);

$dep_finder->add_dependants(qw/Dist::Zilla/);
dd $dep_finder->dependencies;
